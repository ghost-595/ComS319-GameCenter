var path = require('path');
var fse = require('fs-extra');
var _ = require('lodash');

<<<<<<< HEAD
const emitCountMap = new Map();
const compilerHookMap = new WeakMap();

const standardizeFilePaths = (file) => {
  file.name = file.name.replace(/\\/g, '/');
  file.path = file.path.replace(/\\/g, '/');
  return file;
};

=======
>>>>>>> 05f470fce7e701967bb4c2b93d7b7affc096468f
function ManifestPlugin(opts) {
  this.opts = _.assign({
    basePath: '',
    publicPath: '',
    fileName: 'manifest.json',
    stripSrc: null,
    transformExtensions: /^(gz|map)$/i,
    writeToFileEmit: false,
    cache: null
  }, opts || {});
}

ManifestPlugin.getCompilerHooks = (compiler) => {
  var hooks = compilerHookMap.get(compiler);
  if (hooks === undefined) {
    const SyncWaterfallHook = require('tapable').SyncWaterfallHook;
    hooks = {
      afterEmit: new SyncWaterfallHook(['manifest'])
    };
    compilerHookMap.set(compiler, hooks);
  }
  return hooks;
}

ManifestPlugin.prototype.getFileType = function(str) {
  str = str.replace(/\?.*/, '');
  var split = str.split('.');
  var ext = split.pop();
  if (this.opts.transformExtensions.test(ext)) {
    ext = split.pop() + '.' + ext;
  }
  return ext;
};

ManifestPlugin.prototype.apply = function(compiler) {
  var outputName = this.opts.fileName;
  var cache = this.opts.cache || {};
  var moduleAssets = {};

  compiler.plugin("compilation", function (compilation) {
    compilation.plugin('module-asset', function (module, file) {
      moduleAssets[file] = path.join(
          path.dirname(file),
          path.basename(module.userRequest)
      );
<<<<<<< HEAD
    }
  };


  var emit = function(compilation, compileCallback) {
    const emitCount = emitCountMap.get(outputFile) - 1
    emitCountMap.set(outputFile, emitCount);

    var seed = this.opts.seed || {};

    var publicPath = this.opts.publicPath != null ? this.opts.publicPath : compilation.options.output.publicPath;
    var stats = compilation.getStats().toJson({
        // Disable data generation of everything we don't use
        all: false,
        // Add asset Information
        assets: true,
        // Show cached assets (setting this to `false` only shows emitted files)
        cachedAssets: true,
    });
=======
    });
  });

  compiler.plugin('emit', function(compilation, compileCallback) {
    var stats = compilation.getStats().toJson();
    var manifest = {};
>>>>>>> 05f470fce7e701967bb4c2b93d7b7affc096468f

    _.merge(manifest, compilation.chunks.reduce(function(memo, chunk) {
      var chunkName = chunk.name ? chunk.name.replace(this.opts.stripSrc, '') : null;

      // Map original chunk name to output files.
      // For nameless chunks, just map the files directly.
      return chunk.files.reduce(function(memo, file) {
        // Don't add hot updates to manifest
        if (file.indexOf('hot-update') >= 0) {
          return memo;
        }
        if (chunkName) {
          memo[chunkName + '.' + this.getFileType(file)] = file;
        } else {
          memo[file] = file;
        }
        return memo;
      }.bind(this), memo);
    }.bind(this), {}));

    // module assets don't show up in assetsByChunkName.
    // we're getting them this way;
    _.merge(manifest, stats.assets.reduce(function(memo, asset) {
      var name = moduleAssets[asset.name];
      if (name) {
        memo[name] = asset.name;
      }
      return memo;
    }, {}));

    // Append optional basepath onto all references.
    // This allows output path to be reflected in the manifest.
    if (this.opts.basePath) {
      manifest = _.reduce(manifest, function(memo, value, key) {
        memo[this.opts.basePath + key] = this.opts.basePath + value;
        return memo;
      }.bind(this), {});
    } else if (this.opts.publicPath) {
      // Similar to basePath but only affects the value (similar to how
      // output.publicPath turns require('foo/bar') into '/public/foo/bar', see
      // https://github.com/webpack/docs/wiki/configuration#outputpublicpath
      manifest = _.reduce(manifest, function(memo, value, key) {
        memo[key] = this.opts.publicPath + value;
        return memo;
      }.bind(this), {});
    }

<<<<<<< HEAD
    files = files.map(standardizeFilePaths);

    if (this.opts.filter) {
      files = files.filter(this.opts.filter);
    }

    if (this.opts.map) {
      files = files.map(this.opts.map).map(standardizeFilePaths);
    }

    if (this.opts.sort) {
      files = files.sort(this.opts.sort);
    }

    var manifest;
    if (this.opts.generate) {
      const entrypointsArray = Array.from(
        compilation.entrypoints instanceof Map ?
          // Webpack 4+
          compilation.entrypoints.entries() :
          // Webpack 3
          entries(compilation.entrypoints)
      );
      const entrypoints = entrypointsArray.reduce(
        (e, [name, entrypoint]) => Object.assign(e, { [name]: entrypoint.getFiles() }),
        {}
      );
      manifest = this.opts.generate(seed, files, entrypoints);
    } else {
      manifest = files.reduce(function (manifest, file) {
        manifest[file.name] = file.path;
        return manifest;
      }, seed);
    }

    const isLastEmit = emitCount === 0
    if (isLastEmit) {
      var output = this.opts.serialize(manifest);
=======
    Object.keys(manifest).sort().forEach(function(key) {
      cache[key] = manifest[key];
    });

    var json = JSON.stringify(cache, null, 2);
>>>>>>> 05f470fce7e701967bb4c2b93d7b7affc096468f

    compilation.assets[outputName] = {
      source: function() {
        return json;
      },
      size: function() {
        return json.length;
      }
<<<<<<< HEAD
    }

    if (compiler.hooks) {
      ManifestPlugin.getCompilerHooks(compiler).afterEmit.call(manifest);
    } else {
      compilation.applyPluginsAsync('webpack-manifest-plugin-after-emit', manifest, compileCallback);
    }
  }.bind(this);

  function beforeRun (compiler, callback) {
    let emitCount = emitCountMap.get(outputFile) || 0;
    emitCountMap.set(outputFile, emitCount + 1);

    if (callback) {
      callback();
    }
  }

  if (compiler.hooks) {
    const pluginOptions = {
      name: 'ManifestPlugin',
      stage: Infinity
    };

    // Preserve exposure of custom hook in Webpack 4 for back compatability.
    // Going forward, plugins should call `ManifestPlugin.getCompilerHooks(compiler)` directy.
    if (!Object.isFrozen(compiler.hooks)) {
      compiler.hooks.webpackManifestPluginAfterEmit = ManifestPlugin.getCompilerHooks(compiler).afterEmit;
    }
=======
    };
>>>>>>> 05f470fce7e701967bb4c2b93d7b7affc096468f

    if (this.opts.writeToFileEmit) {
      var outputFolder = compilation.options.output.path;
      var outputFile = path.join(outputFolder, this.opts.fileName);

      fse.outputFileSync(outputFile, json);
    }

    compileCallback();
  }.bind(this));
};

module.exports = ManifestPlugin;
